ArrayList<ArrayList<Point>> points = new ArrayList<ArrayList<Point>>(10);

void setup() {
  size(500, 500);
  
  for (int i = 0; i < 10; i++) {
    points.add(new ArrayList<Point>((int)pow(2, i)));
  }
  
  ArrayList<Point> ps = points.get(0);
  ps.add(new Point(0.5, 0.5));
  ps.add(new Point(-0.5, 0.5));
  ps.add(new Point(-0.5, -0.5));
  ps.add(new Point(0.5, -0.5));
}

void clearPoints() {
  for (ArrayList<Point> points : this.points) {
    points.clear();
  }
}

void draw() {
  background(255, 255, 255);
  noStroke();
  // clearPoints();
  
  // calculateFractal(mouseX, mouseY);
  
  for (ArrayList<Point> points : this.points) {
      for (Point p : points) {
        p.display();
      }
  }
}

void calculateFractal(int mouse_x, int mouse_y) {
  float r = 50.0;
  float g = 50.0;
  float b = 50.0;
  
  Point mousePoint = new Point(mouse_x, mouse_y);
  
  // Add initial point
  this.points.get(0).add(new Point(0, 0));
  
  // Calculate fractals and add each point to this.points
  for (int i = 1; i < 10; i++) {
     Point vToTheIthPowerPoint = raisePoint(mousePoint, i);
    
     ArrayList<Point> ithPowerPoints = this.points.get(i);
     ArrayList<Point> iMinus1thPowerPoints = this.points.get(i - 1);
     for (Point basePoint : iMinus1thPowerPoints) {
       // Calculate the next complex numbers (+/- v^i)
        ithPowerPoints.add(addPoint(basePoint, vToTheIthPowerPoint));
        ithPowerPoints.add(subtractPoint(basePoint, vToTheIthPowerPoint));
     }
  }
}

// Translates to zero-based coordinate from non-zero-based coordinate
int translateToActual(int x) {
  return 500 - (x + 3) * (500 / 6);
}

// Translates from zero-based coordinate to non-zero-based coordinate
int translateFromActual(int actual) {
  return (actual / (500 / 6)) - 3;
}

// (a + bi) + (c + di) = (a + c) + (b + d)i
Point addPoint(Point a, Point b) {
  int newReal = a.x + b.x;
  int newImag = a.y + b.y;
  return new Point(newReal, newImag);
}

// (a + bi) - (c + di) = (a - c) + (b - d)i
Point subtractPoint(Point a, Point b) {
  int newReal = a.x - b.x;
  int newImag = a.y - b.y;
  return new Point(newReal, newImag);
}

// raisePoint(new Point(2, 2), 2);
Point raisePoint(Point a, int power) {
    int newReal = 0;
    int newImag = 0;

    if (power == 0) {
        newReal = 1;
        newReal = 1;
    }

    for (int i = 2; i <= power; i++) {
        newReal = (int)pow(newReal, 2) - (int)pow(newImag, 2);
        newImag = 2 * newReal * newImag;
    }

    return new Point(newReal, newImag);
}

// A visual representation of a complex number
class Point {
  int x;
  int y;
  
  // Color
  float r;
  float g;
  float b;
  
  Point(int x, int y) {
    this.x = x;
    this.y = y;
    this.r = 0.0;
    this.g = 0.0;
    this.b = 0.0;
  }
  
  void display() {
    ellipseMode(CENTER);
    fill(this.r, this.g, this.b);
    ellipse(translateToActual(this.x), translateToActual(this.y), 5, 5);
  }
}